/*
 * Copyright (c) 2016, Salesforce.com, Inc.
 * All rights reserved.
 */

////////// Types and Variables //////////

type MaybeIndex : 0..9;
type StrictIndex : 1..9;
type NextIndex : 1..10;

type LedgerId : 1..3;
type ClientId : 1..2;
type BookieId : 1..3;

type Ensemble : Set<BookieId>[1..5];

type LedgerMeta : record {
  state : either {
    Open,
    Closed {
      lac: MaybeIndex,
    },
  },
  ensemble: Ensemble,
};

type ZooKeeper : record {
  ledgers : Vector<LedgerMeta>[LedgerId],
};

var zooKeeper : ZooKeeper;

type Entry : record {
  // value omitted
};

type Ledger : record {
  id: LedgerId,
  entries: Vector<Entry>[StrictIndex],
  lac: MaybeIndex,
  fenced: Boolean,
}

type Bookie : record {
  offline : Boolean,
  ledgers : Vector<Ledger>[1..2],
};

var bookies: Array<Bookie>[BookieId];

type Client : either {
  Inactive,
  CreatingLedger,
  Writer {
    ledgerId : LedgerId,
    ensemble : Vector<BookieId>[1..5],
    lastEntry : Vector<MaybeIndex>[1..5],
    numEntries : MaybeIndex,
  },
  Recovering {
    ledgerId : LedgerId,
    ensemble : Vector<BookieId>[1..5],
    lastEntry : Vector<MaybeIndex>[1..5],
    fenced : Vector<Boolean>[1..5],
  },
};

var clients : Array<Client>[ClientId];

type NodeId : either {
  ClientNode {
    id: ClientId,
  },
  BookieNode {
    id: BookieId,
  },
  ZooKeeperNode,
};

type AddEntryResponseStatus : either {
  AddEntryOk,
  AddEntryFenced,
}

type Message : record {
  from: NodeId,
  to: NodeId,
  sentAt: Time,
  deliverAt: Time,
  payload: either {
    CreateLedgerRequest,
    CreateLedgerResponse {
      ledgerId : LedgerId,
      ensemble : Ensemble,
    },
    CloseLedgerRequest {
      ledgerId : LedgerId,
      lac : MaybeIndex,
    },
    ReadLedgerMetaRequest {
      ledgerId : LedgerId,
    },
    ReadLedgerMetaResponse {
      meta : LedgerMeta,
    },
    AddEntryRequest {
      ledgerId : LedgerId,
      entryId : StrictIndex,
      lac : MaybeIndex,
      recovery : Boolean,
    },
    AddEntryResponse {
      status : AddEntryResponseStatus,
    },
  },
};

var network : MultiSet<Message>[0..20];

////////// Functions //////////

function sendMessage(message: Message) {
  message.sentAt = later(0);
  message.deliverAt = later(urandomRange(10000, 20000));
  push(network, message);
}

function calculateLAC(lastEntry: Vector<MaybeIndex>[1..5]) -> MaybeIndex {
  var lac : MaybeIndex = 0;
  for index in lastEntry {
    var count : 0..5;
    for index2 in lastEntry {
      if index2 >= index {
        count += 1;
      }
    }
    if count * 2 > size(lastEntry) && index > lac {
      lac = index;
    }
  }
  return lac;
}

////////// Rules //////////

// A client requests ZooKeeper to create a new ledger.
rule sendCreateLedger for clientId, client in clients {
  match client {
    Inactive {
      client = CreatingLedger;
      sendMessage(Message {
        from: ClientNode { id: clientId },
        to: ZooKeeperNode,
        payload: CreateLedgerRequest,
      });
    }
    default {
      // do nothing
    }
  }
}

// A client creates a new entry locally, to be replicated later.
rule createEntry
for client in clients {
  match client {
    Writer(writer) {
      writer.numEntries += 1;
      client = writer;
    }
    default {
      // do nothing
    }
  }
}

// A client replicates an entry to a single bookie.
rule sendEntry
for clientId, client in clients
for bookieId, _ in bookies {
  match client {
    Writer(writer) {
      for i, bookieId2 in writer.ensemble {
        if bookieId == bookieId2 {
          if writer.lastEntry[i] < writer.numEntries {
            sendMessage(Message {
              from: ClientNode { id: clientId },
              to: BookieNode { id: bookieId },
              payload: AddEntryRequest {
                ledgerId: writer.ledgerId,
                entryId: writer.lastEntry[i] + 1,
                lac: calculateLAC(writer.lastEntry),
                recovery: False,
              },
            });
          }
          break;
        }
      }
    }
    default {
      /* do nothing */
    }
  }
}

// A writer stops writing and closes its own ledger in ZooKeeper.
rule sendCloseLedger
for clientId, client in clients {
  match client {
    Writer(writer) {
      sendMessage(Message {
        from: ClientNode { id: clientId },
        to: ZooKeeperNode,
        payload: CloseLedgerRequest {
          ledgerId: writer.ledgerId,
          lac: calculateLAC(writer.lastEntry),
        },
      });
      client = Inactive;
    }
    default {
      // do nothing
    }
  }
}


rule handleMessage for message in network {
  if past(message.deliverAt) {
    match message.to {

      ClientNode(to) {
        match message.payload {

          CreateLedgerResponse(payload) {
            var ensemble : Vector<BookieId>[1..5];
            var lastEntry : Vector<MaybeIndex>[1..5];
            for bookieId in payload.ensemble {
              push(ensemble, bookieId);
              push(lastEntry, 0);
            }
            clients[to.id] = Writer {
              ledgerId: payload.ledgerId,
              ensemble: ensemble,
              lastEntry: lastEntry,
            };
          } // CreateLedgerResponse

          AddEntryResponse(payload) {
            match clients[to.id] {
              Writer(writer) {
                match payload.status {
                  AddEntryOk {
                    for i, bookieId in writer.ensemble {
                      if BookieNode { id: bookieId } == message.from {
                        writer.lastEntry[i] += 1;
                        clients[to.id] = writer;
                        break;
                      }
                    }
                  }
                  AddEntryFenced {
                    clients[to.id] = Inactive;
                  }
                }
              }
              default { /* do nothing */ }
            }
          } // AddEntryResponse

          default { assert False; } // other message types
        }
      } // to ClientNode

      BookieNode(to) {
        match message.payload {

          AddEntryRequest(payload) {
            var status : AddEntryResponseStatus = AddEntryOk;
            var ledgerIdx : 0..2;
            for i, ledger in bookies[to.id].ledgers {
              if ledger.id == payload.ledgerId {
                ledgerIdx = i;
                break;
              }
            }
            if ledgerIdx == 0 {
              push(bookies[to.id].ledgers, Ledger {
                id: payload.ledgerId,
              });
              ledgerIdx = size(bookies[to.id].ledgers);
            }
            if bookies[to.id].ledgers[ledgerIdx].fenced &&
               !payload.recovery {
              status = AddEntryFenced;
            }
            if status == AddEntryOk {
              bookies[to.id].ledgers[ledgerIdx].lac = payload.lac;
              if payload.entryId == size(bookies[to.id].ledgers[ledgerIdx].entries) + 1 {
                push(bookies[to.id].ledgers[ledgerIdx].entries, Entry{});
              }
            }
            sendMessage(Message {
              from: message.to,
              to: message.from,
              payload: AddEntryResponse {
                status: status,
              },
            });
          } // AddEntryRequest

          default { assert False; } // other message types
        }
      } // to BookieNode

      ZooKeeperNode {
        match message.payload {

          CreateLedgerRequest {
            if !full(zooKeeper.ledgers) {
              var ensemble : Ensemble;
              push(ensemble, 1);
              push(ensemble, 2);
              push(ensemble, 3);
              push(zooKeeper.ledgers, LedgerMeta{
                ensemble: ensemble,
              });
              var ledgerId : LedgerId = size(zooKeeper.ledgers);
              sendMessage(Message {
                from: message.to,
                to: message.from,
                payload: CreateLedgerResponse {
                  ledgerId: ledgerId,
                  ensemble: ensemble,
                },
              });
            }
          } // CreateLedgerRequest

          CloseLedgerRequest(payload) {
            zooKeeper.ledgers[payload.ledgerId].state = Closed {
              lac: payload.lac,
            };
          } // CloseLedgerRequest

          default { assert False; } // other message types
        }
      } // to ZooKeeperNode

    }
    remove(network, message);
  }
}

rule startRecovery
for client in clients
for ledgerId, _ in zooKeeper.ledgers {
  match client {
    Inactive {
      match zooKeeper.ledgers[ledgerId].state {
        Open {
          var clientEnsemble : Vector<BookieId>[1..5];
          var lastEntry : Vector<MaybeIndex>[1..5];
          var fenced : Vector<Boolean>[1..5];
          for bookieId in zooKeeper.ledgers[ledgerId].ensemble {
            push(clientEnsemble, bookieId);
            push(lastEntry, 0);
            push(fenced, False);
          }
          client = Recovering {
            ledgerId: ledgerId,
            ensemble: clientEnsemble,
            lastEntry: lastEntry,
            fenced: fenced,
          };
        }
        default {
          /* do nothing */
        }
      } // zk ledger state
    }
    default {
      // do nothing
    }
  } // client state
}

rule fence
for client in clients
for bookieId, _ in bookies {
  match client {
    Recovering(recovering) {
      for i, bookieId2 in recovering.ensemble {
        if bookieId != bookieId2 {
          continue;
        }
        if recovering.fenced[i] {
          break;
        }
        for ledger in bookies[bookieId].ledgers {
          if ledger.id == recovering.ledgerId {
            ledger.fenced = True;
            recovering.lastEntry[i] = size(ledger.entries);
            recovering.fenced[i] = True;
            client = recovering;
            break;
          }
        }
      }
    }
    default {
      // do nothing
    }
  } // client state
}

rule completeRecovery
for client in clients {
  match client {
    Recovering(recovering) {
      var count : 0..5;
      var max : MaybeIndex;
      for i, bookieId in recovering.ensemble {
        if recovering.fenced[i] {
          count += 1;
          if recovering.lastEntry[i] > max {
            max = recovering.lastEntry[i];
          }
        }
      }
      if count * 2 > size(recovering.ensemble) {
        zooKeeper.ledgers[recovering.ledgerId].state = Closed {
          lac: max,
        };
        client = Inactive;
      }
    }
    default {
      // do nothing
    }
  } // client state
}
